---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# FLASH-MM

<!-- badges: start -->
<!-- badges: end -->

FLASH-MM is a method (package name: FLASHMM) for analysis of single-cell differential expression using a linear mixed-effects model (LMM). The mixed-effects model is a powerful tool in single-cell studies due to their ability to model intra-subject correlation and inter-subject variability.

FLASHMM package provides two functions, *lmm* and *lmmfit*, for fitting LMM. The *lmm* function uses summary statistics as arguments. The *lmmfit* function is a wrapper function of *lmm*, which directly uses cell-level data and computes the summary statistics inside the function. The lmmfit function is simple to be operated but it has a limitation of memory use. For extremely large scale data, it is recommended to precompute and store the summary statistics and then use *lmm* function to fit LMM.

In summary, FLASHMM package provides the following main functions.

* *lmm*: fit LMM using summary-level data.
* *lmmfit*: fit LMM using cell-level data.
* *lmmtest*: perform statistical tests on the fixed effects and their contrasts.
* *contrast.matrix*: construct contrast matrix of the fixed effects for various comparisons.
* *simuRNAseq*: simulate multi-sample multi-cell-type scRNA-seq data.


## Installation

You can install FLASHMM package from CRAN:

```{r echo = TRUE, results = "hide", message = FALSE}
install.packages("FLASHMM")
```

Or the development version from GitHub:

```{r echo = TRUE, results = "hide", message = FALSE}
devtools::install_github("https://github.com/Baderlab/FLASHMM")
```

## Example

This is a basic example which shows you how to use FLASHMM to perform single-cell differential expression analysis.

```{r}
library(FLASHMM)
```

### Simulating scRNA-seq dataset with *simuRNAseq*

Simulate a multi-sample multi-cell-cluster scRNA-seq dataset that contains 25 samples and 4 clusters (cell-types) with 2 treatments.

```{r dataset}
set.seed(2412)
dat <- simuRNAseq(nGenes = 50, nCells = 1000, nsam = 25, ncls = 4, ntrt = 2, nDEgenes = 6)
names(dat)

#counts and meta data
counts <- dat$counts
metadata <- dat$metadata
head(metadata)
rm(dat)
```

The simulated data contains 

* *counts*: a genes-by-cells matrix of expression counts
* *metadata*: a data frame consisting of samples (sam), cell-types (cls) and treatments (trt).
* *DEgenes*: differetially expressed (DE) genes.

### Differential expression analysis using LMM

The analyses involve following steps: LMM design, LMM fitting, and hypothesis testing.

**1. Model design**

* Y: gene expression profile (log-transformed counts)
* X: design matrix for fixed effects
* Z: design matrix for random effects

```{r}
Y <- log(counts + 1) 
X <- model.matrix(~ 0 + log(libsize) + cls + cls:trt, data = metadata)
##The single-component design matrix
Z <- model.matrix(~ 0 + sam, data = metadata)
d <- ncol(Z) 
```

**2. LMM fitting**

**Option 1**: Fit LMMs with *lmmfit* function using cell-level data.

```{r}
fit <- lmmfit(Y, X, Z, d = d)
```

**Option 2**: Fit LMMs with *lmm* function using summary-level data.

```{r}
##(1) Computing summary statistics
n <- nrow(X)
XX <- t(X)%*%X; XY <- t(Y%*%X)
ZX <- t(Z)%*%X; ZY <- t(Y%*%Z); ZZ <- t(Z)%*%Z
Ynorm <- rowSums(Y*Y)

##(2) Fitting LMMs
fitss <- lmm(XX, XY, ZX, ZY, ZZ, Ynorm = Ynorm, n = n, d = d)

identical(fit, fitss)
```

**3. Hypothesis testing**

```{r, echo = TRUE, message = FALSE, tidy = TRUE, tidy.opts = list(width.cutoff = 80)}
##Testing coefficients (fixed effects)
test <- lmmtest(fit)
#head(test)

##The t-value and p-values are identical with those provided in the LMM fit.
range(test - cbind(t(fit$coef), t(fit$t), t(fit$p)))

fit$p[, 1:4]

#fit$coef[, 1:4]
#fit$t[, 1:4]

##Using contrasts: We can make comparisons using contrasts. For example, the effects of treatment B vs A in all clusters can be tested using the contrast constructed as follows:
ct <- numeric(ncol(X))
index <- grep("B", colnames(X))
ct[index] <- 1/length(index)

test <- lmmtest(fit, contrast = ct)
head(test)
```


## And More

### Using ML method

To use the maximum likelihood (ML) method to fit the LMM, set method = ‘ML’ in the *lmm* and *lmmfit* functions.

```{r LMM_ML, echo = TRUE, message = FALSE, warning = FALSE}
##Fitting LMM using ML method
fit1 <- lmmfit(Y, X, Z, d = d, method = "ML")
```

### LMM with two-components random effects

If appropriate, for example, we also take account of the measurement time as a random effect within a subject, we may fit data using the LMM with two-component random effects.

```{r, echo = TRUE, message = FALSE, tidy = TRUE, tidy.opts = list(width.cutoff = 80)}
##Design matrix for two-component random effects, Za: Suppose the data contains the measurement time points, denoted as 'time', which are randomly generated.
set.seed(2508)
n <- nrow(metadata)
metadata$time <- rnorm(n, 6)*sample(1:2, n, replace = TRUE)
Za <- model.matrix(~ 0 + sam + sam:time, data = metadata)
da <- c(ncol(Za)/2, ncol(Za)/2) #dimension

##Fit the LMM with Two-component random effects.
fit2 <- lmmfit(Y, X, Za, d = da, method = "ML")
```

### Testing variance components

We use both z-test and likelihood ratio test (LRT) to test the second variance component in the LMM with two-component random effects. Since the simulated data was generated by the LMM with single-component random effects, the second variance component should be zero. For the LRT test, the two nested models must be fitted using the same method, either REML or ML, and use the same design matrix, $X$, when using REML method.

```{r}
##(1) z-test for testing the second variance component
##Z-statistics for the second variance component
i <- grep("var2", rownames(fit2$theta)) 
z <- fit2$theta[i, ]/fit2$se.theta[i, ] 
##One-sided z-test p-values for hypotheses:
##H0: theta <= 0 vs H1: theta > 0
p <- pnorm(z, lower.tail = FALSE)

##(2) LRT for testing the second variance component
LRT <- 2*(fit2$logLik - fit1$logLik)
pLRT <- pchisq(LRT, df = 1, lower.tail = FALSE)

##QQ-plot
qqplot(runif(length(p)), p, xlab = "Uniform quantile", ylab = "Z-test p-value")
abline(0, 1, col = "gray")
qqplot(runif(length(pLRT)), pLRT, xlab = "Uniform quantile", ylab = "LRT p-value")
abline(0, 1, col = "gray")
```


```{r}
sessionInfo()
```

# Citation

If you find FLASH-MM useful for your publication, please cite:

Xu & Pouyabahar et al., FLASH-MM: fast and scalable single-cell differential expression analysis using linear mixed-effects models, bioRxiv 2025.04.08.647860; doi: https://doi.org/10.1101/2025.04.08.647860
